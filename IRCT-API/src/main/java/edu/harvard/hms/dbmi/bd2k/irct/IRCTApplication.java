package edu.harvard.hms.dbmi.bd2k.irct;

import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import javax.annotation.PostConstruct;
import javax.ejb.Singleton;
import javax.ejb.Startup;
import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.FlushModeType;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Root;

import org.apache.log4j.Logger;

import edu.harvard.hms.dbmi.bd2k.irct.dataconverter.ResultDataConverter;
import edu.harvard.hms.dbmi.bd2k.irct.event.EventConverterImplementation;
import edu.harvard.hms.dbmi.bd2k.irct.event.IRCTEventListener;
import edu.harvard.hms.dbmi.bd2k.irct.exception.ResourceInterfaceException;
import edu.harvard.hms.dbmi.bd2k.irct.model.join.IRCTJoin;
import edu.harvard.hms.dbmi.bd2k.irct.model.resource.Resource;
import edu.harvard.hms.dbmi.bd2k.irct.model.result.DataConverterImplementation;
import edu.harvard.hms.dbmi.bd2k.irct.model.result.ResultDataType;

/**
 * Manages supported resources and join types for this instance of the IRCT
 * application
 */
@Startup
@Singleton
@ApplicationScoped
public class IRCTApplication {

	@javax.annotation.Resource(mappedName = "java:global/resultDataFolder")
	private String resultDataFolder = null;

	@javax.annotation.Resource(mappedName = "java:global/client_secret")
	private String clientSecret = null;

	private Map<String, Resource> resources;
	private Map<String, IRCTJoin> supportedJoinTypes;
	private Map<ResultDataType, List<DataConverterImplementation>> resultDataConverters;
	
	@Inject
	private EntityManagerFactory objectEntityManager;

	@Inject
	private IRCTEventListener irctEventListener;

	private EntityManager oem;
	private Logger logger = Logger.getLogger(this.getClass());

	/**
	 * Initiates the IRCT Application and loading of the joins, resources, and
	 * predicates.
	 *
	 */
	@PostConstruct
	public void init() {
		logger.info("Starting IRCT Application");
		this.oem = objectEntityManager.createEntityManager();
		this.oem.setFlushMode(FlushModeType.COMMIT);

		logger.info("Loading Data Converters");
		loadDataConverters();
		logger.info("Finished Data Converters");

		logger.info("Loading Event Listeners");
		loadIRCTEventListeners();
		logger.info("Finished Loading Event Listeners");

		logger.info("Loading Join Types");
		loadJoins();
		logger.info("Finished Loading Join Types");

		logger.info("Loading Resources");
		loadResources();
		logger.info("Finished Loading Resources");

		logger.info("Finished Starting IRCT Application");
	}

	public String getVersion() {
		String version = null;
		//log.log(Level.INFO, "getVersion() Starting");

		// try to load from maven properties first
		try {
			Properties p = new Properties();

			// This filename is generated by maven, hopefully.
			String runtimepropertiesFileName = "/META-INF/maven/edu.harvard.hms.dbmi.bd2k.irct/IRCT-API/pom.properties";
			InputStream is = IRCTApplication.class.getResourceAsStream(runtimepropertiesFileName);
			if (is != null) {
				p.load(is);
				version = p.getProperty("version", "");
			}
		} catch (Exception e) {
			logger.error("getVersion() Exception:" + e.getMessage());
		}

		if (version == null) {
			// we could not compute the version so use a blank
			version = "N/A";
		}

		return version;
	}

	/**
	 * Load all the Listeners
	 *
	 */
	private void loadIRCTEventListeners() {
		logger.info("loadIRCTEventListeners() Starting");
		
		this.irctEventListener.init();
		CriteriaBuilder cb = oem.getCriteriaBuilder();
		CriteriaQuery<EventConverterImplementation> criteria = cb.createQuery(EventConverterImplementation.class);
		Root<EventConverterImplementation> load = criteria.from(EventConverterImplementation.class);
		criteria.select(load);
		List<EventConverterImplementation> allEventListeners = oem.createQuery(criteria).getResultList();

		for (EventConverterImplementation irctEvent : allEventListeners) {
			irctEventListener.registerListener(irctEvent);
		}
		logger.info("loadIRCTEventListeners() Finished");
	}

	/**
	 * Load all the Output Data Converters
	 *
	 */
	private void loadDataConverters() {
		logger.info("loadDataConverters() Starting");
		
		this.resultDataConverters = new HashMap<ResultDataType, List<DataConverterImplementation>>();
		CriteriaBuilder cb = oem.getCriteriaBuilder();
		CriteriaQuery<DataConverterImplementation> criteria = cb.createQuery(DataConverterImplementation.class);
		Root<DataConverterImplementation> load = criteria.from(DataConverterImplementation.class);
		criteria.select(load);
		List<DataConverterImplementation> allDCI = oem.createQuery(criteria).getResultList();
		for (DataConverterImplementation dci : allDCI) {
			if (this.resultDataConverters.containsKey(dci.getResultDataType())) {
				this.resultDataConverters.get(dci.getResultDataType()).add(dci);
			} else {
				List<DataConverterImplementation> dciList = new ArrayList<DataConverterImplementation>();
				dciList.add(dci);
				this.resultDataConverters.put(dci.getResultDataType(), dciList);
			}

		}
		logger.info("loadDataConverters() Finished");
	}

	/**
	 * Loads all the joins from the persistence manager
	 */
	private void loadJoins() {
		logger.info("loadJoins() Starting");

		setSupportedJoinTypes(new HashMap<String, IRCTJoin>());
		// Run JPA Query to load the resources
		CriteriaBuilder cb = oem.getCriteriaBuilder();
		CriteriaQuery<IRCTJoin> criteria = cb.createQuery(IRCTJoin.class);
		Root<IRCTJoin> load = criteria.from(IRCTJoin.class);
		criteria.select(load);
		for (IRCTJoin jt : oem.createQuery(criteria).getResultList()) {
			this.supportedJoinTypes.put(jt.getName(), jt);
		}
		
		logger.info("loadJoins() Finished");
	}

	/**
	 *
	 * Loads all the resources from the persistence manager
	 *
	 */
	private void loadResources() {
		setResources(new HashMap<String, Resource>());
		
		// Run JPA Query to load the resources
		CriteriaBuilder cb = oem.getCriteriaBuilder();
		CriteriaQuery<Resource> criteria = cb.createQuery(Resource.class);
		Root<Resource> load = criteria.from(Resource.class);
		criteria.select(load);
		
		for (Resource resource : oem.createQuery(criteria).getResultList()) {
			try {
				logger.info("loadResources() Setting up resource:"+resource.toString()+" "+resource.getId()+" "+resource.getClass().toString());
				resource.setup();
				logger.info("loadResources() resource ```"+resource.getName()+"``` has been loaded");
				
				this.resources.put(resource.getName(), resource);
			} catch (ResourceInterfaceException e) {
				logger.error("loadResources() ResourceInterfaceException: "+e.getMessage());
			} catch (Exception e) {
				logger.error("loadResources() Exception: "+e.getMessage());
			}
		}
		logger.info("loadResources() Loaded " + this.resources.size() + " resources");
	}

	/**
	 * Adds a given resource to the IRCT application
	 *
	 * @param name
	 *            Resource name
	 * @param resource
	 *            Resource
	 */
	public void addResource(String name, Resource resource) {
		// Persist the new resource
		oem.persist(resource);
		this.resources.put(name, resource);
	}

	/**
	 * Removes a resource from the IRCT application
	 *
	 * @param name
	 *            Resource name
	 */
	public void removeResource(String name) {
		// Remove the resource from persistence manager
		oem.remove(this.resources.remove(name));
	}

	/**
	 * Returns true if the resource exists
	 *
	 * True if resource exists, false otherwise
	 *
	 * @param name
	 *            Resource name
	 * @return If resource exists
	 */
	public boolean doesResourceExist(String name) {
		return this.resources.containsKey(name);
	}

	/**
	 * Returns a map of the resources where the Resource name is the key, and
	 * the Resource itself is the value
	 *
	 * @return Resources
	 */
	public Map<String, Resource> getResources() {
		return resources;
	}

	/**
	 * Sets a map of the resources.
	 *
	 * @param resources
	 *            Resources
	 */
	public void setResources(Map<String, Resource> resources) {
		this.resources = resources;
	}

	/**
	 * Returns a map of the supported joins where the Join name is the key, and
	 * the JoinType itself is the value
	 *
	 * @return Supported join types
	 */
	public Map<String, IRCTJoin> getSupportedJoinTypes() {
		return supportedJoinTypes;
	}

	/**
	 * Sets a map of the supported join types
	 *
	 * @param supportedJoinTypes
	 *            Supported join types
	 */
	public void setSupportedJoinTypes(Map<String, IRCTJoin> supportedJoinTypes) {
		this.supportedJoinTypes = supportedJoinTypes;
	}

	/**
	 * Adds a join to the list of supported joins
	 *
	 * @param name
	 *            Join Name
	 * @param join
	 *            Join
	 */
	public void addJoin(String name, IRCTJoin join) {
		// Persist the join
		oem.persist(join);
		this.supportedJoinTypes.put(name, join);
	}

	/**
	 * @return the resultDataConverters
	 */
	public Map<ResultDataType, List<DataConverterImplementation>> getResultDataConverters() {
		return resultDataConverters;
	}

	/**
	 * @param resultDataConverters
	 *            the resultDataConverters to set
	 */
	public void setResultDataConverters(Map<ResultDataType, List<DataConverterImplementation>> resultDataConverters) {
		this.resultDataConverters = resultDataConverters;
	}

	/**
	 * Returns a dataconveter for a given datatype and format
	 *
	 * @param dataType
	 *            DataType
	 * @param format
	 *            Format
	 * @return DataConverter
	 */
	public ResultDataConverter getResultDataConverter(ResultDataType dataType, String format) {
		List<DataConverterImplementation> dciList = this.resultDataConverters.get(dataType);

		for (DataConverterImplementation dci : dciList) {
			if (dci.getFormat().equals(format)) {

				return dci.getDataConverter();
			}
		}
		return null;
	}

	/**
	 * Removes a join from the list of supported joins
	 *
	 * @param name
	 *            Join name
	 */
	public void removeJoin(String name) {
		// Removes the supported joins from the persistence manager
		oem.remove(this.supportedJoinTypes.remove(name));
	}

	/**
	 * Returns true if the join type is supported
	 *
	 * True if join type is supported, otherwise it false
	 *
	 * @param name
	 *            Resource name
	 * @return If resource exists
	 */
	public boolean doesJoinExists(String name) {
		return this.supportedJoinTypes.containsKey(name);
	}

	/**
	 * Get the name of the result data folder
	 *
	 * @return Result Data Folder
	 */
	public String getResultDataFolder() {
		return resultDataFolder;
	}

	/**
	 * Sets the name of the result data folder
	 *
	 * @param resultDataFolder
	 *            Result Data Folder
	 */
	public void setResultDataFolder(String resultDataFolder) {
		this.resultDataFolder = resultDataFolder;
	}

	/**
	 * @return the clientSecret
	 */
	public String getClientSecret() {
		return clientSecret;
	}

	/**
	 * @param clientSecret the clientSecret to set
	 */
	public void setClientSecret(String clientSecret) {
		this.clientSecret = clientSecret;
	}

}
