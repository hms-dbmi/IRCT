package edu.harvard.hms.dbmi.bd2k.irct.cl.util;


import org.junit.Test;
import org.junit.runner.RunWith;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PowerMockIgnore;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.powermock.modules.junit4.PowerMockRunner;

import javax.servlet.http.*;
import java.io.*;

import static junit.framework.Assert.assertNotNull;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.powermock.api.mockito.PowerMockito.when;

@PowerMockIgnore({"javax.crypto.*" })
@RunWith(PowerMockRunner.class)
@PrepareForTest(Utilities.class)
public class UtilitiesTest {

    private Utilities cut = new Utilities();

    @Test
    public void testExtractEmailFromJWT() throws UnsupportedEncodingException, IOException{

        /*
        JWT returned in mock HttpServletRequest: (generated separately)
        email = "test@email.com"
        environment="test.environment"
        client_id="testClientId1234567890abcdefghij"
        client_secret="testClientSecretabcdefghijklmnopqrstuvwx_12345678910111213141516"

        'sub': "samlp|"+email,
        'email': email,
        "aud": client_id,
        "description": "Autogenerated token for "+environment,
        "exp":calendar.timegm(time.strptime('Jan 30, 2019 @ 00:00:00 EST', '%b %d, %Y @ %H:%M:%S EST')),
        "iss":calendar.timegm(time.gmtime())
        */

        String clientSecret = "testClientSecretabcdefghijklmnopqrstuvwx_12345678910111213141516";
        String userField = "testField";
        String validToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJzYW1scHx0ZXN0QGVtYWlsLmNvbSIsImF1ZCI6InRlc3RDbGllbnRJZDEyMzQ1Njc4OTBhYmNkZWZnaGlqIiwiaXNzIjoxNTE4MTIxMDcwLCJleHAiOjE1NDg4MDY0MDAsImVtYWlsIjoidGVzdEBlbWFpbC5jb20iLCJkZXNjcmlwdGlvbiI6IkF1dG9nZW5lcmF0ZWQgdG9rZW4gZm9yIHRlc3QuZW52aXJvbm1lbnQifQ.2PiZQbHkEc1uIkEZ9F8j5RhlCfVE35BjRc0i3CcWP8s";

        HttpServletRequest req = PowerMockito.mock(HttpServletRequest.class);
        when(req.getHeader("Authorization")).thenReturn("Bearer " + validToken);

        //Fake field should return null
        String result = cut.extractEmailFromJWT(req, clientSecret, userField);
        assertNull(result);

        result = cut.extractEmailFromJWT(req, clientSecret, "sub");
        assertNotNull(result);
        assertEquals(result, "samlp|test@email.com");

        result = cut.extractEmailFromJWT(req, clientSecret, "email");
        assertNotNull(result);
        assertEquals(result, "test@email.com");

        //Missing userField should return null
        result = cut.extractEmailFromJWT(req, clientSecret, null);
        assertNull(result);

        try {
            result = cut.extractEmailFromJWT(req, "invalidClientSecret", "email");
            //It shouldn't have gotten past here
            fail();
        } catch (Exception e){
            //Good!  There should be an exception
            assertEquals("Could not validate with a plain, not-encoded client secret. The Token's Signature resulted invalid when verified using the Algorithm: HmacSHA256", e.getMessage());
        }

        //Test invalid token
        String invalidToken = validToken.replaceAll("y", "X");
        when(req.getHeader("Authorization")).thenReturn("Bearer " + invalidToken);
        try {
            result = cut.extractEmailFromJWT(req, clientSecret, "email");
            //It shouldn't have gotten past here
            fail();
        } catch (Exception e){
            assertTrue(e.getMessage().startsWith("Could not validate with a plain, not-encoded client secret."));
        }


    }
}
